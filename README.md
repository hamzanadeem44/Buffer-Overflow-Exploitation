# Table of contents
* [1 Identifying the buffer overflow vulnerability](#1-identifying-the-buffer-overflow-vulnerability)
* [2 Pre-requisites](#2-pre-requisites)
* [3 General Steps to follow](#3-general-steps-to-follow)
    * [3.1 Create the fuzzy payload](#31-create-the-fuzzy-payload)
    * [3.2 Get the exact number of bytes to reach at EIP](#32-get-the-exact-number-of-bytes)
    * [3.3 Identify the number of bytes to store shell code](#33-identify-the-number-of-bytes-to-store-shell-code)
    * [3.4 Identify the bad characters](#34-identify-the-bad-characters)
    * [3.5 Generate shell code](#35-generate-shell-code)
    * [3.6 Get the JMP ESP instruction address](#36-get-the-jmp-esp-instruction-address)
    * [3.7 Finalize the payload and exploit](#37-finalize-the-payload-and-exploit)

<hr>

# 1. Identifying the buffer overflow vulnerability
- Identification of buffer overflow vulnerability by only looking at the source code of the program or software is the skill of a good Penetration Tester. 

- But it can also be done by using fuzzing techniques and analyzing the response or behaviour of the affected application/program/software i.e if program crashes by passing some large input that program was not expecting and it will not only fill its allocated space but also the surrounding memory areas, and you can see the error message like ``Program crashed unexpectedly`` or ``Access violation while accessing/reading/writing to hexadecimal memory address``.

# 2. Pre-requisites
- If you are writing your own buffer overflow vulnerable program then you will need to follow the pre-requisites to successfully test this vulnerability:
    - **Step # 1: Disable ASLR Protection**: For Linux the command will be: ```echo 0 | sudo tee /proc/sys/kernel/randomize_va_space```
    - **Step # 2: Compile the vulnerable code using gcc:** For Linux you will need to compile the program using gcc with the command ```gcc -g -o exploit vulnerable_program.c -fno-stack-protector -z execstack```
    - **Step # 3: Debug the compiled file using gdb(GNU Debugger)** ``gdb ./exploit -q``
- Some Common **gdb** flags
    - To Set the intel disassembly point in gdb ``set disassembly-flavor intel``
    - To pass the input using python to file ``run $(python -c 'print "A"*500'); ``
    - To set the breakpoints
        - ``b lineno``
        - ``b functionname``
        - ``b *address``
    - To view/analyze the memrory starting from Stack Pointer Register: ``x/200wb $esp`` (it will show you the 200 words starting from ESP)
    - To jump to next line of code: ``next or n``
    - To run the program until break point or exit: ``continue or c``

# 3. General steps to follow
### 3.1 Create the fuzzy payload
### 3.2 Get the exact number of bytes
### 3.3 Identify the number of bytes to store shell code
### 3.4 Identify the bad characters
### 3.5 Generate shell code
### 3.6 Get the JMP ESP instruction address
### 3.7 Finalize the payload and exploit

