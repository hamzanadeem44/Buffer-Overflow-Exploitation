# Table of contents
* [1 Identifying the buffer overflow vulnerability](#1-identifying-the-buffer-overflow-vulnerability)
* [2 Pre-requisites](#2-pre-requisites)
* [3 General Steps to follow](#3-general-steps-to-follow)
    * [3.1 Create the fuzzy payload](#31-step-#-1-:-create-the-fuzzy-payload)
    * [3.2 Get the exact number of bytes to reach at EIP](#32-get-the-exact-number-of-bytes)
    * [3.3 Identify the number of bytes to store shell code](#33-identify-the-number-of-bytes-to-store-shell-code)
    * [3.4 Identify the bad characters](#34-identify-the-bad-characters)
    * [3.5 Generate shell code](#35-generate-shell-code)
    * [3.6 Get the JMP ESP instruction address](#36-get-the-jmp-esp-instruction-address)
    * [3.7 Finalize the payload and exploit](#37-finalize-the-payload-and-exploit)

<hr>

# 1. Identifying the buffer overflow vulnerability
- Identification of buffer overflow vulnerability by only looking at the source code of the program or software is the skill of a good Penetration Tester. For example if you see that in case of C Programming Language *strcpy, strcmp* (and some other vulnerable functions) are being used without any proper validation then there are chances of buffer overflow.

- But it can also be done by using fuzzing techniques and analyzing the response or behaviour of the affected application/program/software i.e if program crashes by passing some large input that program was not expecting and it will not only fill its allocated space but also the surrounding memory areas, and you can see the error message like ``Program crashed unexpectedly`` or ``Access violation while accessing/reading/writing to hexadecimal memory address``.

# 2. Pre-requisites
- If you are writing your own buffer overflow vulnerable program then you will need to follow the pre-requisites to successfully test this vulnerability:
    - **Step # 1: Disable ASLR Protection**: For Linux the command will be: ```echo 0 | sudo tee /proc/sys/kernel/randomize_va_space```
    - **Step # 2: Compile the vulnerable code using gcc:** For Linux you will need to compile the program using gcc with the command ```gcc -g -o exploit vulnerable_program.c -fno-stack-protector -z execstack```
    - **Step # 3: Debug the compiled file using gdb(GNU Debugger)** ``gdb ./exploit -q``
- Some Common **gdb** flags
    - To Set the intel disassembly point in gdb ``set disassembly-flavor intel``
    - To pass the input using python to file ``run $(python -c 'print "A"*500'); ``
    - To set the breakpoints
        - ``b lineno``
        - ``b functionname``
        - ``b *address``
    - To view/analyze the memrory starting from Stack Pointer Register: ``x/200wb $esp`` (it will show you the 200 words starting from ESP)
    - To jump to next line of code: ``next or n``
    - To run the program until break point or exit: ``continue or c``

# 3. General steps to follow
- When you are confirmed that program is being crashed while passing large input values to its parameters and you are ready to test the exploitation of buffer overflow vulnerability then by following some common steps, you can successfully exploit this vulnerability. Those methods are as follows:
    
    ### 3.1 Step # 1: Create the fuzzy payload
    - In this step, we will use Kali Linux binary ``/usr/bin/msf-pattern_create`` for this purpose. Some common usage are as:
        - To create fuzzing payload of 1000 bytes: ``/usr/bin/msf-pattern_create -l 1000``
    ### 3.2 Step # 2: Get the exact number of bytes
    - In this step, you will need to pass the payload generated in above step to the program as input and identify the address where program crashed.
    - You can get that address value from the value of EIP register. For example you see ``76413176`` as the value of the EIP when program got crashed by passing the fuzzing payload.
    - Then pass that value ``76413176`` to the Kali Linux binary ``/usr/bin/msf-pattern_offset`` using command: ``/usr/bin/msf-pattern_offset -q 76413176`` and you will see the output as:

        ```
        [*] Exact match at offset 634
        ```
    - It means total 634 bytes are required to reach at the EIP register.

    ### 3.3 Identify the number of bytes to store shell code
    ### 3.4 Identify the bad characters
    ### 3.5 Generate shell code
    ### 3.6 Get the JMP ESP instruction address
    ### 3.7 Finalize the payload and exploit

